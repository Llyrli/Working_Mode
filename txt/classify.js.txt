// classify.js — v1 API, no response_mime_type; strong anti-"other"; user custom categories are first-class.
// Heuristics -> LLM -> anti-other fallback.

export async function classifyPage({ url, title }, settings) {
  const domain = extractDomain(url);

  // A) learned rules first
  const learned = (settings.learnedRules || {})[domain];
  if (learned && inSet(learned, settings.categories)) {
    return { category: learned, reason: "learned rule", confidence: 1.0 };
  }

  // B) local heuristics (bias away from 'other', respect custom)
  const h = heuristicCategory(url, title, settings);
  if (h) {
    return { category: h, reason: "heuristic match", confidence: 0.9, suggest_rule: { apply:true, domain, category:h, type:"whitelist" } };
  }

  // C) no API key -> fallback to heuristics-other
  if (!settings.apiKey) {
    return { category: "other", reason: "no api key", confidence: 0.0 };
  }

  // D) Prompt with strong instruction "prefer a concrete category over other"
  const cats = Array.from(new Set((settings.categories || []).map(String))).filter(Boolean);
  const prompt = buildPrompt({ url, title, domain, categories: cats });

  const trials = dedupe([
    settings.model && { ver:"v1", model: settings.model.trim() },
    { ver:"v1", model:"gemini-2.0-flash" },
    { ver:"v1", model:"gemini-2.0-pro" }
  ].filter(Boolean), x => `${x.ver}:${x.model}`);

  for (const t of trials) {
    const r = await callGemini(t.ver, t.model, settings.apiKey, prompt);
    if (r.ok && r.data?.category) {
      let cat = r.data.category;
      // normalize to one of cats; if 'other' but heuristics can guess, prefer guess
      if (!inSet(cat, cats)) cat = "other";
      if (cat.toLowerCase() === "other") {
        const guess = heuristicCategory(url, title, settings) || antiOtherFallback(url, title, cats);
        if (guess) cat = guess;
      }
      return { category: cat, reason: r.data.reason || "LLM", confidence: r.data.confidence ?? 0.6, suggest_rule: r.data.suggest_rule };
    }
  }

  // E) total fallback
  const guess = heuristicCategory(url, title, settings) || antiOtherFallback(url, title, cats) || "other";
  return { category: guess, reason: "fallback", confidence: 0.1 };
}

/* ============== Helpers ============== */
function inSet(name, arr) {
  if (!name || !arr) return false;
  const n = String(name).toLowerCase();
  return arr.some(x => String(x).toLowerCase() === n);
}
function extractDomain(u) { try { return new URL(u).hostname; } catch { return "unknown"; } }
function dedupe(arr, keyFn){ const s=new Set(); const out=[]; for(const x of arr){const k=keyFn(x); if(!s.has(k)){s.add(k); out.push(x);}} return out; }
function clamp01(x){ x=Number(x); return isFinite(x)?Math.max(0,Math.min(1,x)):0; }
function normToOneOf(c, categories) {
  const s = String(c||"").toLowerCase();
  const hit = (categories||[]).find(x => String(x).toLowerCase() === s);
  return hit || "other";
}

function buildPrompt({ url, title, domain, categories }) {
  const catsLine = categories.join(", ");
  // Few-shot + very explicit anti-"other"
  return `
You are a strict JSON machine. Choose ONE category from: ${catsLine}.
Unless it is truly unknown or generic, do NOT use "other".

Guidelines:
- Prefer specific categories if they semantically fit.
- "other" is only for truly unclassifiable pages (e.g., about:blank).
- Use URL host/path and title.
- Output STRICT JSON with keys: category, reason, confidence, suggest_rule.

Examples:
Input: URL=https://www.youtube.com/watch?v=abc, Title="Lo-fi beats"
Output: {"category":"entertainment","reason":"video streaming","confidence":0.95,"suggest_rule":{"apply":true,"domain":"youtube.com","category":"entertainment","type":"whitelist"}}

Input: URL=https://github.com/user/repo, Title="Readme"
Output: {"category":"work","reason":"code hosting","confidence":0.9,"suggest_rule":{"apply":true,"domain":"github.com","category":"work","type":"whitelist"}}

Input: URL=https://www.duolingo.com/learn, Title="Practice English"
Output: {"category":"English_learning","reason":"language learning","confidence":0.92,"suggest_rule":{"apply":true,"domain":"duolingo.com","category":"English_learning","type":"whitelist"}}

Now classify the page:

URL: ${url}
Title: ${title}
Domain: ${domain}

ONLY return JSON like:
{"category":"<one of [${catsLine}]>","reason":"<short>","confidence":0.0-1.0,"suggest_rule":{"apply":true|false,"domain":"${domain}","category":"<same>","type":"whitelist"}}
`.trim();
}

/* ----- Heuristics ----- */
function heuristicCategory(url, title, settings) {
  const u = String(url||"").toLowerCase();
  const t = String(title||"").toLowerCase();
  const cats = (settings.categories || []).map(s=>String(s).toLowerCase());
  const has = (name) => cats.includes(String(name).toLowerCase());

  // user custom categories: if a category name includes "english" or "learning", and page matches learning sites → that category
  const customEnglishLike = (settings.categories || []).find(c => /english|language.*learn|learn.*english/i.test(c));
  if (customEnglishLike) {
    if (/duolingo|bbc\.co\.uk\/learningenglish|ef\.com|ielts|toefl|voa.*learning|quizlet|dictionary\.cambridge|deepl|youglish/i.test(u+t)) {
      return customEnglishLike;
    }
  }

  // common sites
  if (/youtube|netflix|bilibili|twitch|iqiyi|youku|spotify|music\.apple\.com/i.test(u+t)) {
    if (has("entertainment")) return "entertainment";
  }
  if (/twitter|x\.com|weibo|reddit|facebook|instagram|tiktok/i.test(u+t)) {
    if (has("social")) return "social";
  }
  if (/docs\.google|drive\.google|notion|confluence|jira|github|gitlab|figma|slack|linear|asana|microsoft\.sharepoint/i.test(u+t)) {
    if (has("work")) return "work";
  }
  if (/wikipedia|arxiv|khanacademy|coursera|udemy|edx|brilliant|mit\.edu\/open|classroom\.google/i.test(u+t)) {
    if (has("study")) return "study";
  }
  if (/mail\.google|outlook\.live|calendar\.google|maps\.google|bank|alipay|paypal|wise\.com|booking|airbnb|map\./i.test(u+t)) {
    if (has("utility")) return "utility";
  }

  // If a custom category name appears literally in title/path, pick it
  for (const c of (settings.categories || [])) {
    const s = String(c).toLowerCase();
    if (!s || s === "other") continue;
    if (u.includes(s) || t.includes(s)) return c;
  }

  return null;
}

function antiOtherFallback(url, title, categories) {
  const u = String(url||"").toLowerCase();
  const t = String(title||"").toLowerCase();
  const has = (name) => categories.some(x => String(x).toLowerCase() === String(name).toLowerCase());

  if (has("entertainment") && /youtube|netflix|bilibili|twitch|iqiyi|youku/i.test(u+t)) return "entertainment";
  if (has("social") && /(twitter|x\.com|weibo|reddit|facebook|instagram|tiktok)/i.test(u+t)) return "social";
  if (has("work") && /(docs\.google|drive\.google|notion|confluence|jira|github|gitlab|figma|slack|linear)/i.test(u+t)) return "work";
  if (has("study") && /(wikipedia|arxiv|khanacademy|coursera|udemy|edx|brilliant)/i.test(u+t)) return "study";
  if (has("utility") && /(mail\.google|outlook\.live|calendar\.google|maps\.google|bank|alipay|paypal|wise\.com)/i.test(u+t)) return "utility";
  return null;
}

/* ----- Gemini v1 ----- */
async function callGemini(ver, model, apiKey, prompt) {
  const endpoint = `https://generativelanguage.googleapis.com/${ver}/models/${model}:generateContent?key=${encodeURIComponent(apiKey)}`;
  try {
    const res = await fetch(endpoint, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ contents: [{ role: "user", parts: [{ text: prompt }]}], generationConfig: { temperature: 0 } })
    });
    if (!res.ok) {
      const t = await res.text();
      console.warn("[Working Mode] Gemini HTTP error:", t);
      return { ok: false };
    }
    const data = await res.json();
    const raw = data?.candidates?.[0]?.content?.parts?.[0]?.text ?? data?.candidates?.[0]?.content?.parts?.[0]?.string_value ?? "";
    const json = extractJSON(raw);
    if (!json) return { ok: false };
    const out = {
      category: json.category,
      reason: (json.reason ?? "").toString().slice(0, 60) || "",
      confidence: clamp01(json.confidence),
      suggest_rule: sanitizeSuggestRule(json.suggest_rule)
    };
    return { ok: !!out.category, data: out };
  } catch (e) {
    console.error("[Working Mode] Gemini call error:", e);
    return { ok: false };
  }
}
function sanitizeSuggestRule(sr) {
  if (!sr || typeof sr !== "object") return { apply:false, domain:"", category:"", type:"whitelist" };
  const domain = typeof sr.domain === "string" ? sr.domain : "";
  const category = typeof sr.category === "string" ? sr.category : "";
  const apply = !!sr.apply && !!domain && !!category;
  return { apply, domain, category, type:"whitelist" };
}
function extractJSON(text) {
  if (!text) return null;
  let t = String(text).trim();
  t = t.replace(/^```json\s*/i, "").replace(/^```\s*/i, "").replace(/```$/i, "").trim();
  const direct = safeParse(t);
  if (direct) return direct;
  const m = t.match(/\{[\s\S]*\}/);
  if (m) { const p = safeParse(m[0]); if (p) return p; }
  return null;
}
function safeParse(s){ try { return JSON.parse(s); } catch { return null; } }
